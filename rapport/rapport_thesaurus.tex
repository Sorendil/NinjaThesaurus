\documentclass[12pt,a4paper]{article}
\renewcommand{\baselinestretch}{1.5}
\usepackage[latin1]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\title{Projet Base de Données Avancées - Thésaurus}
\author{J. Deguilhem, M. Denis, S. Gautheron , J. Mitrail, A. Rossi, C. Vidal \\Master 1 Informatique - Université Montpellier 2}
\usepackage[absolute]{textpos}

\begin{document}
\maketitle{}
\pagebreak
\tableofcontents{}
\pagebreak



\section{Introduction}%Introduction ou Sujet
Dans le cadre du Master 1 Informatique à l'Université Montpellier 2, nous avons été amenés à réaliser un projet de groupe pour le cours de base de données avancées dirigé par Thérèse Libourel.
	
Le projet proposé consiste à analyser et implémenter un système de gestion de vocabulaire partagé. Un vocabulaire partagé, aussi appelé Thésaurus, est une liste de termes organisés selon des liens qui les unissent. Les termes sont reliés entre eux par diverses relations comme la synonymie, la généralisation, la spécialisation, l'association...
	
Le projet qui nous a été assigné " le thésaurus " est pertinent par rapport au sujet de la base de données parce qu'au final un thésaurus est un outil linguistique qui permet de voir les relations entre des concepts concernant un domaine de connaissance. Ainsi l'une de notre mission est de trouver la structure optimale qui mettra en avant les relations sémantiques et d'équivalence

L'équipe de projet est constitué de six étudiants : Julien Deguilhem, Maïlys Denis, Sébastien Gautheron, Johann Mitrail, Anthony Rossi et Colin Vidal.

Pour le thésaurus, nous avons choisi de travailler sur le thème des animaux. C'est un thème vaste qui permet de créer beaucoup de lien entre tous les animaux, en partant du nom latin de l'animal jusqu'à créer des liens de synonymie, d'espèces, de races, de cousins...

\section{Cahier des charges}%Cahier des charges ou analyse des besoins

Le projet a débuté début novembre 2013 et doit se terminer début janvier 2014.

A l'issue de cette période l'équipe de projet présentera le suivi du projet à travers une soutenance orale et rendra un rapport de projet concis.

\subsection{Fonctionnalités}
L'application sera un site web ergonomique et simple d'utilisation.

L'application demandée devra permettre à un utilisateur de rechercher un mot dans le thésaurus et pouvoir avoir la liste des termes qui lui sont liés. Il pourra voir les termes synonymes, les généralisations et spécialisations du mot recherché.

Puis, l'utilisateur pourra naviguer de termes en termes grâce à la liste des mots retournés lors de la recherche d'un précédent mot.

De plus, l'utilisateur aura la possibilité d'ajouter, d'éditer ou de supprimer des synonymes, des spécialisations ou des généralisations à un mot. 

\subsection{Fiabilité}
L'application avertit l'utilisateur dans le cas où le mot recherché n'est pas dans la base de données et après l'ajout, la suppression ou l'édition d'un mot.

Lors d'ajout(de suppression et d'édition) de relations à un mot, l'application est en mesure de refuser si la relation compromet le bon fonctionnement de la base de données.
 


\section{Gestion de Projet}
%Diagramme de gantt
\includegraphics[width=15cm]{thesaurusgantt.png}

Pour le projet, nous avons commencé par analyser le sujet. Nous avons confronter nos différents diagramme de classes et nous avons confronté nos idées durant près d'un mois pour produire le diagramme de classes et de cas d'utilisation.

Une fois l'analyse terminée, nous avons décidé de nous répartir les tâches selon les envies de chacun et les besoins du projet.

Anthony est responsables du site web qui sera donc l'interface de notre thésaurus. Colin prend en charge la mise en place  du serveur et de la base de données  afin de pouvoir entamer le projet. Sébastien  s'occupe des diagrammes de classes et  d'utilisation. Johann et Maïlys sont responsables de tout ce qui est rédaction du rapport, organisation du projet et résumé des réunions.

\section{Modélisation}
\subsection{Modèle sous forme d'arbre}
Dans un contexte de thésaurus traitant des animaux, notre première approche fût de concevoir un modèle objet relationnel qui prennent en compte par sa conception (c'est à dire sans avoir recours à des contraintes particulières) la notion de hiérarchie entre les termes, illustrant implicitement les relations de généralisations et spécialisations entre des termes vedettes. Afin d'illustrer d'autres aspects relationnels entre les termes, nous pouvons ajouter des relations au travers de nouvelles classes, comme l'illustre la classe de Synonymie, qui regrouperait alors des termes non vedettes.

Le modèle est intéressant dans notre situation puisque léger à mettre en ?uvre : pas besoin d'utiliser de triggers ou de contraintes complexes pour assurer l'intégrité de la base. En revanche il en est pas moins extrêmement statique, et très spécialisé. On peut imaginer des domaines où une relation de hiérarchie n'est pas nécessaire, où encore un domaine où l'héritage multiple est indispensable, ce que ne peux fournir ce modèle. Par ailleurs, l'ajout de différents types de relations est relativement pénible, puisqu'il impose de modifier le modèle, et probablement les autres couches du programme.

De plus, la contrainte d'utiliser l'objet relationnel pose différents problèmes au niveau du stockage des données. Il n'est pas possible d'intégrer dans des tables imbriquées les n?uds que contiennent un n?ud père (relation de spécialisation) car cela rendrait la recherche d'un terme vedette très complexe (il faudrait parcourir chaque branche de l'arbre à partir de la racine, sans index possible). L'utilisation de références d'objet s'avère alors utile, mais le problème de suppression de n?uds se pose alors : il n'est pas possible sous Oracle d'avoir une suppression automatique d'un tuple étant référencé dans un autre tuple qu'on supprime, contrairement au relationnel, où les clés étrangères et l'option FOREIGN KEY permet d'assurer cette fonction. On serait alors obligé d'avoir recourt à des déclencheurs particulièrement pénibles à mettre en ?uvre (et sujet à être modifié si l'on rajoute de nouvelles relations).

\subsection{Modèle sous forme de graphe orienté (ou réseau lexical)}
Afin de trouver un palliatif aux problèmes d souplesse que pose le modèle précédent, nous nous sommes inspirés de la vision des réseaux lexicaux telle qu'on peut la retrouver sur JeuxDeMots. Il s'agit d'un graphe orienté, où les n?uds représentent des termes et les arcs des relations, valués et orientés. Dans le cadre du thésaurus, seule l'orientation de ces relations nous intéresse.

L'intérêt de ce modèle est qu'il offre une souplesse extrême puisqu'on peut aisément manipuler toute sorte de relations entre tous les n?uds de la base de données, permettant de s'adapter facilement à de nombreux types de thésaurus. Du point de vue de l'implémentation, deux classes (une classe contenant les termes, une autre les relations) suffisent.

Afin d'assurer des contraintes entre différentes relations (par exemple, le fait que la relation de synonymie puisse s'exprimer entre un descripteur vedette et un non vedette uniquement), nous avons décidé de concevoir une classe supplémentaire, qui répertorie l'ensemble des relations possibles du modèle, et qui indique par deux booléens si le terme source de la relation doit être vedette, et si le terme de destination de la relation doit l'être également. Cet ajout permet d'adapter le modèle à de nouveaux contextes (nouvelles relations, contraintes entre relations) sans modifier le schéma, simplement en ajoutant des tuples dans la classe répertoriant les relations.

Cela nécessite un déclencheur assez lourd qui consiste lors de chaque ajout ou modification de relation à vérifier l'état des termes (vedettes ou non) avant d'effectuer la modification dans la base de données. Néanmoins, ce déclencheur n'a pas besoin d'être modifié ou adapté en fonction du contexte, ce qui est un atout vis à vis du modèle précédent.

\subsection{Modèle retenu}
(todo)
- second modèle retenu, bien que pas parfait car
- exemple pbleme caisse voiture et caisse contenair
- pbleme relation spécialisation/généralisation non explicite mais pas possible de faire mieux àcause de problemes de polysémie

%Diagramme de classe à insérer
%Diagramme de cas d'utilisation à insérer

\section{Spécifications}%Spécifications ou choix techniques
Afin de simplifier le développement (l'installation et la configuration d'Oracle n'étant pas triviale), nous avons mis en place une architecture centralisée basée sur une machine virtuelle KVM hébergeant une distribution GNU/Linux CentOS 6.4 sur l'un de nos serveurs personnels.

\subsection{Serveur de gestion de base de données}
Il était nécessaire d'utiliser un SGBD gérant l'objet relationnel pour ce projet. À l'heure actuelle, les deux SGBD éprouvés et supportant cette norme sont Oracle et PostgreSQL. Notre choix s'est porté sur Oracle 11g en raison de notre formation sur ce type de système.

Notons que nous aurions préféré utilisé PostgreSQL en raison de son aspect libre et fortement utilisé en entreprise, mais la complexité d'utilisation d'un tel SGBD que l'on ne maîtrise pas aurait prit un temps disproportionné sur ce projet.

\subsection{Serveur Web}
Nous avons utilisé Apache 2.2 pour le service web de notre application. Le choix du langage de programmation s'est porté sur PHP (avec le module OCI pour interaction avec le SGBD Oracle), en raison de sa maîtrise par tous les membres du projet.

\subsection{Serveur de gestion de version}
Dans le contexte de gestion de projet, nous avons utilisé le service fourni par GitHub pour centraliser et gérer nos versions du projet afin de faciliter l'ajout, la modification et la suppression de code. 


\section{Implémentation}

\subsection{Base de Données}
Nous avons implémenté le schéma UML précédent sur une base Oracle.
Nous avons crée les trois types et finalement trois tables correspondant aux classes Descripteur, Relations et Type\_relation.
De plus, nous avons décidé de faire intervenir des Trigger PL/SQL afin que la base de données reste stable et sans erreur :
\begin{description}
  \item[CHK\_MATCH\_RELATION :]  Vérifie que la relation crée suit le schéma, c'est à dire qu'une relation synonymes doit comportée au moins un terme vedette, généralisation 2 termes vedettes et spécialisation 2 termes vedettes, sinon renvoie une erreur et ne crée pas la relation.
  \item[CHK\_UNIQUE\_RELATION :]  Vérifie que la relation à créer n'est pas déjà existante, sinon ne crée pas la relation et renvoie un message.
\end{description} 

Pour le moment, notre table\_relations ne comportent que trois libelles : Synonyme, Généralisation et Spécialisation du mot courant.

\subsection{Interface Web}


Notre interface web comporte deux pages principales:
\begin{description}
  \item[L'accueil :] une zone de recherche de descripteur, une zone d'ajout de descripteur vedette ou non, et une zone de présentation du projet.
  \item[L'affichage du descripteur courant :] une zone de recherche de descripteur, une zone d'ajout de descripteur vedette ou non, une zone d'affichage des relations du descripteur courant et pour chacune des relations une zone d'ajout de relation à ce même descripteur.
\end{description} 

\section{Conclusion}
\subsection{Difficultés rencontrées}
Nous avons rencontré quelques difficultés concernant la phase d'analyse du sujet en particulier l'élaboration du diagramme de classe. Notre premier diagramme de classe était fait en sorte que l'on puisse créer une hiérarchie de mots sous forme d'arbre mais aussi une liste de synonyme. 

Cependant, nous l'avons repensé car l'idée de la génération d'un arbre n'est pas adapté au problème de l'utilisation de ce thésaurus dans toute sorte de domaine (et non pas exclusivement au domaine des animaux).

\subsection{Résultats}
\end{document}
